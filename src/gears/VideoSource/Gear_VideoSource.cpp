/* Gear_VideoSource.cpp
 * Copyright (C) 2004 Mathieu Guindon, Julien Keable
 * This file is part of Drone.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
//inspired from Using libavformat and libavcodec by Martin Bï¿½hme (boehme@inb.uni-luebeckREMOVETHIS.de) 


#include <iostream>
#include "Gear_VideoSource.h"
#include "Engine.h"

#include "GearMaker.h"

extern "C" {           
  Gear* makeGear(Schema *schema, QString uniqueName)
  {
    return new Gear_VideoSource(schema, uniqueName);
  }  
  GearInfo getGearInfo()
  {
    GearInfo gearInfo;
    gearInfo.name = "VideoSource";
    gearInfo.classification = GearClassifications::video().IO().instance();
    return gearInfo;
  }
}

const QString Gear_VideoSource::SETTING_FILENAME = "Filename";

Gear_VideoSource::Gear_VideoSource(Schema *schema, QString uniqueName) : 
Gear(schema, "VideoSource", uniqueName),
_currentMovie(""),
_formatContext(NULL),
_codecContext(NULL),
_codec(NULL),
_frame(NULL),
_frameRGBA(NULL),
_sws_ctx(NULL),
_buffer(NULL),
_movieReady(false)
{    
  addPlug(_VIDEO_OUT = new PlugOut<VideoRGBAType>(this, "ImgOut", false));
  addPlug(_AUDIO_OUT = new PlugOut<SignalType>(this, "AudioOut", false));

  addPlug(_FINISH_OUT = new PlugOut<ValueType>(this, "FinishOut", false));
  
  std::vector<AbstractPlug*> atLeastOneOfThem;
  atLeastOneOfThem.push_back(_VIDEO_OUT);
  atLeastOneOfThem.push_back(_AUDIO_OUT);
  setPlugAtLeastOneNeeded(atLeastOneOfThem);

  addPlug(_RESET_IN = new PlugIn<ValueType>(this, "Reset", false, new ValueType(0, 0, 1)));
  addPlug(_MOVIE_IN = new PlugIn<StringType>(this, "Movie", false));

  //_settings.add(Property::FILENAME, SETTING_FILENAME)->valueStr("");    

  av_register_all();
	_VIDEO_OUT->sleeping(true);
	_AUDIO_OUT->sleeping(true);
}

Gear_VideoSource::~Gear_VideoSource()
{
  freeResources();
}

void Gear_VideoSource::freeResources()
{
  if (_buffer)  
    delete [] _buffer;
  
  if (_frameRGBA)  
    av_free(_frameRGBA);
  
  if (_frame)  
    av_free(_frame);
  
  if (_codecContext)
    avcodec_close(_codecContext);
  
  if (_formatContext)
    avformat_close_input(&_formatContext);

  _movieReady=false;
	_VIDEO_OUT->sleeping(true);
	unSynch();
}

bool Gear_VideoSource::loadMovie(QString filename)
{
  std::cout << "opening movie : " << filename << std::endl;

  //free previously allocated structures
  freeResources();

  if (avformat_open_input(&_formatContext, filename.c_str(), NULL,  NULL)<0)
  {
    std::cout << "fail to open movie!" << std::endl;
    return false;
  }

  if (avformat_find_stream_info(_formatContext,NULL)<0)
  {
    std::cout << "fail to find stream info!" << std::endl;
    return false;
  }

  av_dump_format(_formatContext, 0, filename.c_str(), 0);

  _videoStreamIndex=-1;
  for (int i=0; i<_formatContext->nb_streams; i++)
    if (_formatContext->streams[i]->codec->codec_type == AVMEDIA_TYPE_VIDEO)
    {
      _videoStreamIndex=i;
      break;
    }

  if (_videoStreamIndex<0)
  {
    std::cout << "no video stream!" << std::endl;
    return false;
  }

  _codecContext=(_formatContext->streams[_videoStreamIndex]->codec);       
  _codec = avcodec_find_decoder(_codecContext->codec_id);
  if (!_codec)
  {
    std::cout << "no appropriate codec found!" << std::endl;
    return false;
  }

  std::cout << "using codec : " << _codec->name << std::endl;
  if (avcodec_open2(_codecContext, _codec,NULL ) < 0)
  {
    std::cout << "fail to open codec!" << std::endl;
    return false;       
  }

  // Hack to correct wrong frame rates that seem to be generated by some 
  // codecs
//  if (_codecContext->time_baseframe_rate>1000 && _codecContext->frame_rate_base==1)
 //   _codecContext->frame_rate_base=1000;

  // Allocate video frame
  _frame=avcodec_alloc_frame();
  if (_frame==NULL)
  {
    std::cout << "fail to allocate frame!" << std::endl;
    return false;
  }

  // Allocate rgba frame
  _frameRGBA=avcodec_alloc_frame();
  if (_frameRGBA==NULL)
  {
    std::cout << "fail to allocate frame!" << std::endl;
    return false;
  }

  // Determine required buffer size and allocate buffer
  int numBytes=avpicture_get_size(PIX_FMT_RGB24, _codecContext->width, _codecContext->height);
  _buffer=new uint8_t[numBytes];

  // new since libavcodec5.?  -> we must use libswscale instead of img_convert
  if(_sws_ctx!=NULL)
    sws_freeContext(_sws_ctx);
    _sws_ctx =
    sws_getCachedContext
    (_sws_ctx,
        _codecContext->width,
        _codecContext->height,
        _codecContext->pix_fmt,
        _codecContext->width,
        _codecContext->height,
        PIX_FMT_RGB24,
        SWS_BILINEAR,
        NULL,
        NULL,
        NULL
    );
  
  
  
  
  
  // Assign appropriate parts of buffer to image planes in _frameRGBA
  avpicture_fill((AVPicture *)_frameRGBA, _buffer, PIX_FMT_RGB24, _codecContext->width, _codecContext->height);

  _firstFrameTime=_formatContext->start_time;

  _movieReady=true;
	_VIDEO_OUT->sleeping(false);
	
	return true;
}

void Gear_VideoSource::runVideo()
{
  int frameFinished=0;

	if (_currentMovie != _MOVIE_IN->type()->value())
	{
		_currentMovie=_MOVIE_IN->type()->value();
		if (!loadMovie(_currentMovie))
			return;
	}

	if (!_movieReady)
		return;

  _VIDEO_OUT->type()->resize(_codecContext->width, _codecContext->height);

  if ((int)_RESET_IN->type()->value() == 1)
  {
    av_seek_frame(_formatContext, -1, _formatContext->start_time, AVSEEK_FLAG_BACKWARD);
  }
    

  //loop until we get a videoframe
  //if we reach end, return to the beginning
  if (av_read_frame(_formatContext, &_packet)<0)
	{
    av_seek_frame(_formatContext, -1, _formatContext->start_time, AVSEEK_FLAG_BACKWARD); 
		_FINISH_OUT->type()->setValue(1.0f);
	}
	else
		_FINISH_OUT->type()->setValue(0.0f);
	
  while (_packet.stream_index!=_videoStreamIndex)
  {    
    av_free_packet(&_packet);
    if (av_read_frame(_formatContext, &_packet)<0)
      av_seek_frame(_formatContext, -1, _formatContext->start_time, AVSEEK_FLAG_BACKWARD);
  }
  
  // Decode video frame
  do
  {    
    avcodec_decode_video2(_codecContext, _frame, &frameFinished, &_packet);
  } while (!frameFinished);

  // Convert the image from its native format to RGBA
  
  sws_scale
        (
            _sws_ctx,
            (uint8_t const * const *)_frame->data,
            _frame->linesize,
            0,
            _codecContext->height,
            _frameRGBA->data,
            _frameRGBA->linesize
        );

  
  //img_convert((AVPicture *)_frameRGBA, PIX_FMT_RGB24, (AVPicture*)_frame, _codecContext->pix_fmt, _codecContext->width, _codecContext->height);

  register char *out=(char*)_VIDEO_OUT->type()->data();
  register char *in=(char*)_frameRGBA->data[0];  
  register int size=_codecContext->width*_codecContext->height;
  for (register int i=0;i<size;i++)
  {
    *out++=*in++;
    *out++=*in++;
    *out++=*in++;
    *out++=255;
  }

  // Free the packet that was allocated by av_read_frame
  av_free_packet(&_packet);
}



